# 1. 绪论
## 1.1 课题来源背景
## 1.2 国内外发展动态
## 1.3 背景技术介绍
云计算中的系统学+经济学中的预定

## 1.4 文章结构介绍

# 2. 需求
## 2.1 深度学习业务需求分析
## 2.2 任务调度与资源分配
## 2.3 需求总结及检验标准
- 通过功能测试，准确执行作业（包括起始时间、硬件资源分配、其他作业描述信息等）；
- 根据云资源利用率计算公式，接入核心调度层之后云资源利用率有提高；
（公式： 静态集群的资源利用率=Sum(集群中某机器的CPU占用率在一段时间内的均值 * cpu_ratio + GPU占用率 * gpu_ratio + 内存占用率 * mem_ratio)/某集群机器总数，其中各项ratio之和为1。对于动态伸缩的集群，该公式在计算的时间粒度上作相应调整即可。）

# 3. 设计
## 3.1 总览
用例图；数据流向图；架构设计图。

注：
- 下述"系统环境软件依赖描述"指的是该模块所依赖的所有硬件和软件的描述，包括硬件设施、操作系统、编程语言、框架、第三方库等；
- 在设计部分，以上描述相较于实现部分的同类描述，较为简略许多；
- 下述"设计职能目标描述"指的是该模块的预期功能描述，后续篇章会对该目标进行验收；
- 下述"设计性能目标描述"指的是该模块的预期性能描述，后续篇章会对该目标进行验收；

架构设计图中，包含四大模块：
1. 云基础设施层
2. 核心调度层
3. 核心应用层
4. 用户接入层

该架构应该是分布式的（每一层的部署都可以是分布式的，层与层也是分布式的）。有一些配置需要共享。

## 3.2 云基础设施层

1. 系统环境和软件依赖描述（尤其是所依赖的底层云服务的具体描述，在这里具体依据阿里云提供的服务进行描述）
2. 设计职能目标描述
3. 设计性能目标描述

云基础设施层提供封装接口，以下简称"云接口"，参考分布式任务队列celery的设计：
![](http://opkk27k9n.bkt.clouddn.com/18-4-16/1740887.jpg)
几大关键子模块：
- user 
- broker
- worker
- backend

在本系统的设计中，对应上述几个子模块相应地有：
- broker是云接口对外（对user）暴露的作业调度信息接入点。
- worker依据broker中的作业调度信息，执行作业并追踪作业的整个生命周期。
- backend是由接口调用者指定的，被worker用于存储作业的相关信息。

## 3.2 核心调度层
这一层的设计主要参考微软和斯坦福研究者提出的ERA框架，表现为"ERA核心"。

1. 系统环境和软件依赖描述
3. 设计职能目标描述（尤其是在整个系统架构中的地位）
4. 设计性能目标描述
5. 定价和调度算法描述

## 3.3 核心应用层
这一层的设计主要参考需求分析中的2.1节"深度学习业务需求分析"。

1. 系统环境和软件依赖描述
2. 设计职能目标描述
3. 设计性能目标描述

核心应用层直接接受客户端的作业请求，并转发给核心调度层，从核心调度层获取响应后再向客户端发出响应，全程对于客户端来说是同步的（非异步），这就要求核心调度层具有非常高的响应速度。

## 3.4 用户接入层
1. 系统环境和软件依赖描述
2. 设计职能目标描述
3. 设计性能目标描述

参数列表，使用案例，流程图。**从略**。

# 4. 实现
## 4.1 总览

- 共享配置中心采用redis作为存储。

## 4.2 云基础设施层
本系统对于基础设施层的实现，表现为"基于阿里云容器集群服务的Celery应用"。

本节详细介绍以下内容：
1. 根据作业描述对作业进行"实例化"的过程；
2. "实例化"过程所依赖的容器镜像持续集成方案；
3. "追踪作业整个生命周期"的过程细节；
3. 以上内容所涉及的背景技术介绍。

具体说来, broker选用redis，backend选用mysql+redis。

Q&A:
- 为什么基于阿里云容器集群服务？

>底层基础设施不是本系统的核心内容，选用成熟方案，可以快速构建系统。

- 为什么选用Celery？（注：Celery官方只有Python版本）
>这部分代码需求变更频繁，且对性能不敏感，因此选用Python；分布式的设计要求，Celery是Python社区事实上的分布式异步任务标准。

## 4.3 核心调度层
本系统对该层的实现，表现为"ERA核心"。由Go语言编程实现。
模块结构：
- goERACore
    - cloud
        >cloud模块订阅了"accepted_queue"频道；承担云接口的user角色，收到订阅消息后向云接口的broker中发送异步任务消息。由于Celery本身只提供了Python版本，本模块需要实现Celery的protocol。
    - core
        >实现了定价和调度算法。接受作业请求后，将调度信息发布到redis中的"accepted_queue"频道。
    - user
        >提供tcp接口接受作业请求。

Q&A:
- 为什么用Go？
    >对于原有云系统来说，核心调度层应该是非侵入式的、语言无关的，而设计方案中论证了核心调度层应具有较高的响应性能，这就要求算法和网络都要足够快，算法方面，Go语言是编译型语言，相较于脚本语言速度优势明显；网络方面，Go语言对并发的天然支持也有巨大优势。
    
- 为什么要有"accepted_queue"频道？
    >解耦。（子模块core和cloud的解耦，事实上，本系统的运行状态下，cloud子模块表现为一个单独的进程，user子模块表现为另一个单独的进程，而core子模块是供user子模块调用的。）

## 4.4 核心应用层
本系统对该层的实现，表现为"应用服务器"。
Python实现，基于flask框架，使用JSON作为RESTful-API数据交换格式，使用MySQL作为主力数据库，采用uwsgi+nginx+supervisor部署。

描述信息即可。

Q&A：
- 为什么用flask？

- 为什么用mysql？

- 为什么用RESTful API?


## 4.5 用户接入层
本系统对该层的实现，表现为"客户端CLI"。
Python实现，Python2/Python3兼容，可以使用pip/anaconda等包管理工具安装。


# 5. 测试
## 5.1 功能测试
验收设计一章中所提到的各项"设计职能目标描述"。

### 5.1.1 基础设施层
### 5.1.2 核心调度层
### 5.1.3 核心应用层
### 5.1.4 用户接入层
### 5.1.4 系统整体功能测试

## 5.2 性能测试
### 5.1.1 基础设施层
### 5.1.2 核心调度层
### 5.1.3 核心应用层
### 5.1.4 用户接入层
### 5.1.4 系统整体性能测试

## 5.3 测试总结
包含一些涉及系统成败的关键指标数据分析。

# 6. 总结
# 7. 致谢